/**
 * Copyright (c) 2024 Matthias Melcher
 */


/*
 This little toy program displays the content of an Apple Newton MessagePad 
 screen on a modern TFT screen. It does that by grabbing pixel data from
 the internal flat ribbon connector. It then converts the stream of black and
 white pixels into a series of SPI commands and sends them to a screen
 controlled by an ST7769S.

 The current implementation reads the port using one of the CPUs. A future
 version should use DMA and the PIO to read the data and reformat it for 
 easier conversion.

 The SPI output uses the CPU to convert 1bit B&W data into a 16 bit color
 data stream. This need to be made much faster.

 The color information is then copied to the TFT using a bunch of SPI commands.
 Again, this could be done using DMA.

 The LCD port provides only black and white data. The 16 grayscales of the 
 Newton display seem to be generated by changing the output per pixel over 
 time, effectively generating a blinking effect that renders gray thanks to 
 the slow refresh of the 90's LCD technology. To solve this in emulation
 my require averaging pixle brightness over time.

 It would be really nice to support more displays and display types, including 
 e-enk displays. This would require some additional math to keed screen updates
 at a minimum.

 It should be possible to read the touch information from the display SPI and 
 output the analog signal required by the MessagePad.
*/

#include "pico/stdlib.h"
#include "hardware/spi.h"
#include "hardware/pio.h"
#include "hardware/dma.h"
#include "hardware/structs/bus_ctrl.h"
#include <stdio.h>

// ----------------------------------------------------------------------------
// Initialize our little LED for control puposes
const uint led_pin = PICO_DEFAULT_LED_PIN;
bool led_state = false;

void led_init() {
    gpio_init(led_pin);
    gpio_set_dir(led_pin, GPIO_OUT);
}

void led_toggle() {
    led_state = ~led_state;
    gpio_put(led_pin, led_state);
}

// ----------------------------------------------------------------------------
// Define all pins for LCD input via flat ribbon cable
const uint lcd_pin_vsync = 2;   // 75Hz
const uint lcd_pin_hsync = 3;   // 24kHz
const uint lcd_pin_pclk = 4;    // 1.5Mhz
const uint lcd_pin_d0 = 6;      // 1.5MHz B&W pixel data
const uint lcd_data_pins = 8;   // 8 data pins

const uint lcd_line_bytes = 60; // 60 bytes times 8 gives us 480 pixels across
const uint lcd_num_lines = 320; // we send 320 lines of image data
// store the entire screen contents as LCD pixel data
uint8_t lcd_line[lcd_num_lines][lcd_line_bytes];

// Initialize the ports for reading LCD data. This should really be done
// using a properly set DMA channel.
void lcd_init() {
    gpio_init(lcd_pin_vsync);
    gpio_set_dir(lcd_pin_vsync, GPIO_IN);
    gpio_init(lcd_pin_hsync);
    gpio_set_dir(lcd_pin_hsync, GPIO_IN);
    gpio_init(lcd_pin_pclk);
    gpio_set_dir(lcd_pin_pclk, GPIO_IN);
    for (int i=0; i<lcd_data_pins; i++) {
        gpio_init(lcd_pin_d0 + i);
        gpio_set_dir(lcd_pin_d0 + i, GPIO_IN);
    }
}

// Wait for the rising edge of the vertical sync.
void lcd_wait_vsync() {
    // wait util vsync goes H which is the start of the vertical sync pulse
    while (gpio_get(lcd_pin_vsync) == 1) { }
    while (gpio_get(lcd_pin_vsync) == 0) { }
}

// Garb one line of pixel data from the LCD connector
void lcd_scan_line(int y) {
    // wait for the falling ege of the hsync signal
    while (gpio_get(lcd_pin_hsync) == 0) { }
    while (gpio_get(lcd_pin_hsync) == 1) { }
    // prepare to read 80 bytes
    uint8_t *dst = lcd_line[y];
    for (int i=lcd_line_bytes; i>0; --i) {
        // wait for the falling edge of the pixel clock
        while (gpio_get(lcd_pin_pclk) == 0) { }
        while (gpio_get(lcd_pin_pclk) == 1) { }
        // read all PIO bits at once, shift them into position, 
        // and write them to the buffer
        *dst++ = (((*(uint32_t*)(SIO_BASE + 0x004)) >> lcd_pin_d0));
    }
}
// ----------------------------------------------------------------------------
// Define all pins for the TFT screen output via SPI
const uint tft_pin_cs = 17;
const uint tft_pin_sck = 18;
const uint tft_pin_mosi = 19;
const uint tft_pin_miso = 16;
const uint tft_pin_reset = 14;
const uint tft_pin_dc = 15;     // select data or control

// TFT related variables
spi_inst_t *tft_spi = spi0;     // use this SPI port
uint16_t tft_line[480];         // store one line of pixels for TFT


// This app currently support the ST7796s with a 480x320 TFT display
// https://www.displayfuture.com/Display/datasheet/controller/ST7796s.pdf

// Send a command a number of bytes the TFT controller
void tft_send(uint8_t cmd, size_t size=0, const uint8_t *data=nullptr) {
    gpio_put(tft_pin_dc, 0);
    gpio_put(tft_pin_cs, 0);
    sleep_us(1);
    spi_write_blocking(tft_spi, &cmd, 1);
    if (size) {
        sleep_us(1);
        gpio_put(tft_pin_dc, 1);
        sleep_us(1);
        spi_write_blocking(tft_spi, data, size);
    }
    sleep_us(1);
    gpio_put(tft_pin_cs, 1);
}

// Configure a GPIO pin for the TFT diplay port
void tft_pin_config_out(uint pin, bool value) {
    gpio_init(pin);
    gpio_set_dir(pin, GPIO_OUT);
    gpio_put(pin, value);
}

// Initialize SPI and boot the display controller
void tft_init() {
    // define the pins we use directly
    tft_pin_config_out(tft_pin_cs, 1);
    tft_pin_config_out(tft_pin_dc, 1);
    tft_pin_config_out(tft_pin_reset, 1);

    // initialize the SPI port
    spi_init(tft_spi, 62.5 * 1000 * 1000);  // 62.5MHz, can probably be more if needed
    spi_set_format( spi0,           // SPI instance
                    8,              // Number of bits per transfer
                    SPI_CPOL_1,     // Polarity (CPOL)
                    SPI_CPHA_1,     // Phase (CPHA)
                    SPI_MSB_FIRST);
    gpio_set_function(tft_pin_sck, GPIO_FUNC_SPI);
    gpio_set_function(tft_pin_mosi, GPIO_FUNC_SPI);
    gpio_set_function(tft_pin_miso, GPIO_FUNC_SPI);

    // reset the TFT controller
    gpio_put(tft_pin_reset, 0);
    sleep_ms(100);
    gpio_put(tft_pin_reset, 1);
    sleep_ms(100);

    tft_send(0xf0, 1, (uint8_t*)"\xc3");    // Command Set Control
    tft_send(0xf0, 1, (uint8_t*)"\x96");    // Command Set Control
    tft_send(0xc5, 1, (uint8_t*)"\x1c");
    tft_send(0x36, 1, (uint8_t*)"\xe8");    // 
    tft_send(0x3a, 1, (uint8_t*)"\x55");    // 
    tft_send(0xb0, 1, (uint8_t*)"\x80");    // 
    tft_send(0xb4, 1, (uint8_t*)"\x01");    // 
    tft_send(0xb6, 3, (uint8_t*)"\x80\x02\x3b");
    tft_send(0xb7, 1, (uint8_t*)"\xc6");    // 
    tft_send(0xf0, 1, (uint8_t*)"\x69");    // 
    tft_send(0xf0, 1, (uint8_t*)"\x3c");    // 
    tft_send(0x11);
    sleep_ms(150);
    tft_send(0x29);
    sleep_ms(150);
}

// Send a horizontal line of pixel data to the TFT
// y is the position on the screen
// if rpt is greater 1, the line will be duplicated downward.
void tft_send_line(int y, int rpt) {
    static uint8_t cmd_col[] = {0, 0, 479 >> 8, 479 & 0xff};
    tft_send(0x2a, 4, cmd_col);
    uint8_t cmd_row[] = {(uint8_t)(y>>8), (uint8_t)y, (uint8_t)((y+rpt)>>8), (uint8_t)(y+rpt)};
    tft_send(0x2b, 4, cmd_row);
    static uint8_t cmd12[100] = {0};
    tft_send(0x2c, 480 * 2, (uint8_t *)tft_line);
    for (int i = 0; i < rpt; i++) {
        tft_send(0x3c, 480 * 2, (uint8_t *)tft_line);
    }
}

#if 0
// Leftovers from playing around with the DMA. Please ignore.
PIO pio = pio0;
uint sm = 0;
uint dma_chan = 0;
void init_n2_dma() {
    // Grant high bus priority to the DMA, so it can shove the processors out
    // of the way. This should only be needed if you are pushing things up to
    // >16bits/clk here, i.e. if you need to saturate the bus completely.
    bus_ctrl_hw->priority = BUSCTRL_BUS_PRIORITY_DMA_W_BITS | BUSCTRL_BUS_PRIORITY_DMA_R_BITS;

    pio = pio0;
    sm = 0;
    dma_chan = 0;

    uint16_t capture_prog_instr = pio_encode_in(pio_pins, 8);
    struct pio_program capture_prog = {
            .instructions = &capture_prog_instr,
            .length = 1,
            .origin = -1
    };
    uint offset = pio_add_program(pio, &capture_prog);

    // Configure state machine to loop over this `in` instruction forever,
    // with autopush enabled.
    pio_sm_config c = pio_get_default_sm_config();
    sm_config_set_in_pins(&c, lcd_pin_d0);
    sm_config_set_wrap(&c, offset, offset);
    sm_config_set_clkdiv(&c, 10.0f);
    // Note that we may push at a < 32 bit threshold if pin_count does not
    // divide 32. We are using shift-to-right, so the sample data ends up
    // left-justified in the FIFO in this case, with some zeroes at the LSBs.
    sm_config_set_in_shift(&c, true, true, 8);
    sm_config_set_fifo_join(&c, PIO_FIFO_JOIN_RX);
    pio_sm_init(pio, sm, offset, &c);
}
#endif

// Create a lookup table for 16 grayscales in to 16 bit RGB.
// This is currently not very useful because the MessagePad LCD output
// is only B&W and simulates grays by switching pixels on and off over time.
#define TFT_GRAY(a) ( (a<<4) | ((a>>1)|((a&0x01)<<15)) | (a<<9) )
uint16_t lcd_convert(uint8_t px) {
    #if 0 // inverse
    static const uint16_t px_lut[16] = {
        TFT_GRAY(0x00), TFT_GRAY(0x01), TFT_GRAY(0x02), TFT_GRAY(0x03),
        TFT_GRAY(0x04), TFT_GRAY(0x05), TFT_GRAY(0x06), TFT_GRAY(0x07),
        TFT_GRAY(0x08), TFT_GRAY(0x09), TFT_GRAY(0x0a), TFT_GRAY(0x0b),
        TFT_GRAY(0x0c), TFT_GRAY(0x0d), TFT_GRAY(0x0e), TFT_GRAY(0x0f),
    };
    #elif 1 // original
    static const uint16_t px_lut[16] = {
        TFT_GRAY(0x0f), TFT_GRAY(0x0e), TFT_GRAY(0x0d), TFT_GRAY(0x0c),
        TFT_GRAY(0x0b), TFT_GRAY(0x0a), TFT_GRAY(0x09), TFT_GRAY(0x08),
        TFT_GRAY(0x07), TFT_GRAY(0x06), TFT_GRAY(0x05), TFT_GRAY(0x04),
        TFT_GRAY(0x03), TFT_GRAY(0x02), TFT_GRAY(0x01), TFT_GRAY(0x00),
    };
    #else // bit swapped
    static const uint16_t px_lut[16] = {
        TFT_GRAY(0x00), TFT_GRAY(0x08), TFT_GRAY(0x04), TFT_GRAY(0x0c),
        TFT_GRAY(0x02), TFT_GRAY(0x0a), TFT_GRAY(0x06), TFT_GRAY(0x0e),
        TFT_GRAY(0x01), TFT_GRAY(0x09), TFT_GRAY(0x05), TFT_GRAY(0x0d),
        TFT_GRAY(0x03), TFT_GRAY(0x0b), TFT_GRAY(0x07), TFT_GRAY(0x0f),
    };
    #endif
    return px_lut[px&0x0f];
}

// Conver the raw LCD data into 16bit RGB data for the TFT.
// y is the source line buffer index.
// Only a single target buffer is used. The image is trasfered line by line.
void lcd_line_to_tft(int y) {
    uint8_t *src = lcd_line[y];
    uint16_t *dst = tft_line;
    for (int i=0; i<lcd_line_bytes; i++) {
        uint8_t p1 = *src++;
        *dst++ = lcd_convert((p1>>4)&0x08);
        *dst++ = lcd_convert((p1>>3)&0x08);
        *dst++ = lcd_convert((p1>>2)&0x08);
        *dst++ = lcd_convert((p1>>1)&0x08);
        *dst++ = lcd_convert((p1   )&0x08);
        *dst++ = lcd_convert((p1<<1)&0x08);
        *dst++ = lcd_convert((p1<<2)&0x08);
        *dst++ = lcd_convert((p1<<3)&0x08);
    }
}

// Main entry point.
int main() {
    stdio_init_all();
    led_init();
    lcd_init();
    tft_init();

    for (;;) {
        led_toggle();

        // wait for the start of the screen data
        lcd_wait_vsync();
        // read all 320 lines and store them in RAM
        for (int i=0; i<lcd_num_lines; i++) {
            lcd_scan_line(i);
        }
        // convert the screen line by line and send the RGB data to the TFT
        for (int i=0; i<lcd_num_lines; i++) {
            lcd_line_to_tft(i);
            tft_send_line(i, 1);
        }
    }
}
